Q1. A. ליצור מופע חדש של המחלקה ולבצע בו אתחול של משתנים

Q2. B. @classmethod מקבל את המחלקה כפרמטר ראשון (cls), ו־@staticmethod לא מקבל אובייקט בכלל

Q3. B. להחזיר ייצוג טקסטואלי של האובייקט כשמדפיסים אותו

Q4. C. ההשוואה תתבצע לפי כתובת הזיכרון של המופעים

Q5. B. לממש את המתודות iter ו-next

Q6. B. מחזיר ערך מספרי ייחודי שמייצג את האובייקט עבור שימוש במבני נתונים כמו dict או set

Q7. B. שימוש באופרטור + בין מופע של המחלקה לכל אובייקט שתואם את הלוגיקה שבמתודה

Q8. C. תתקבל שגיאה מסוג TypeError 

Q9. C. היא מגדירה ממשק מחייב למחלקות שיורשות ממנה

Q10. B. תתקבל שגיאה בזמן הידור

Q11. C. תתקבל שגיאה מיד כשנטען הקובץ 

Q12. C. התוצאה עלולה להיות לא צפויה בגלל מצב של race condition

Q13. C. *args אוסף ארגומנטים לפי מיקום ו־**kwargs אוסף ארגומנטים לפי מפתח

Q14. B. כדי לאפשר שימוש באובייקט כמפתח במילון או כחבר בקבוצת set

Q15. B. מגביל את פייתון כך שרק thread אחד יכול להריץ קוד פייתון בכל רגע נתון

Q16. C. logging מאפשר רמות דיווח שונות וכתיבה לקובץ או קונסולה

Q17. C. יודפס "Done" ואז תיזרק שגיאת ZeroDivisionError כי אין except מתאים

Q18. C. להשתמש ב־memory_profiler עם @profile כדי למדוד שימוש בזיכרון

Q19. B. מצב שבו שני אובייקטים מחזיקים הפניה אחד לשני, כך שלא ניתן לפנות את הזיכרון

Q20. B. שני האובייקטים יישארו בזיכרון כי יש ביניהם הפניה מעגלית

Q21. B. לשים את ה־import בתוך הפונקציה שזקוקה לו

Q22. B. מספר המשתנים שמצביעים על אותו אובייקט בזיכרון

Q23. B. היא מחזיקה הפניה לאובייקט בלי למנוע מה־ garbage collector למחוק אותו

Q24. C. מאפשר שליטה על גישה, אימות ולוגיקה לפני קריאה או שינוי של הערך

Q25. C. כי multiprocessing עוקף את מגבלת ה־GIL ולכן מתאים לעומסים חישוביים






















